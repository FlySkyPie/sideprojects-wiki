{"title":"一種基於力學破壞對方塊世界中的建築結構進行的懲罰","text":"原本是想寫應力分析的演算法，但是不知道為什麼寫出來反而變得像是彎矩分析。\n\n### 緣起\n\n> ~~其實我看 Minecraft 的物理引擎不爽很久了~~ \n\nMinecraft 原生的遊戲環境允許浮空方塊，\n當然在有秩序的伺服器或守序的玩家遊玩下，\n這樣的配置可以生成諸如浮空城、飛艇...之類美麗雄偉的造物，\n但是訓練過程的 AI 是相當無序的，\n可以想見 AI 對地形造成的破壞會十分接近 2b2t 重生點的程度。\n在混亂的環境中成長的 AI 勢必會把浮空方塊視作環境特徵而妥善利用它，\n這與我所期望能夠建立帝國般秩序的 AI 相左。\n\n這幾天剛好想到：\n> 為什麼沒有 3D 版本的 Falling-sand game？🤔\n\n以 Powder Toy [^Powder_Toy]為例，它基本就是一個微縮的二維物理模擬器，甚至能夠在之中模擬核電廠的運作。最小單元是像素意味著它的運算方式是一格一格的，而不是在向量空間飛行的質點。似乎可以很容易得出結論：三維的 Falling-sand game 應該長得像是 Minecraft。在查了一些 Powder Toy 的影片之後，程式魂被悄悄的點燃了。\n\n接著確認看看有沒有人寫過 Minecraft 的重力模組：有。\n\nBlockPhysics 賦予了土壤和沙子（很離散的）流動性，並且讓磚塊遵守某種規則而不掉落，其規則基本上來自周圍 3x3x3 其他的方塊。看得出來他就是寫了一些判斷式去偵測方塊周遭的方塊並且判斷掉不掉落，以及放置方塊時的加入一些判斷。[^BlockPhysics]\n\n恩...這不是我想要的，主要是因為它仍然允許一些奇形怪狀的建築，我希望透過力學約束逼迫機器學習產出的建築物必須遵從某種程度上的結構設計。\n\n於是我建了兩個演算法的模型：一個用來處理撞擊破壞、一個用來處理重力破壞，前者不是本文的討論重點，讓我們先把重點放在重力破壞上吧。\n\n### 總之先寫程式\n\n![](#gravity-flow.webp)\n\n一開始的概念是這樣的：\n> 每過一個微量時間，「重力能」就會被施加在微元素上；「重力能」會從「重力能」的地方往低的方向流，形成「重力流」；最後流向大地，大地邊界會消除「重力能」。\n> 微元素累積的「重力能」大於逃溢能時（臨界），微元素就會發生破壞。\n\n簡單建了個模型就開始寫程式：\n$$\ng'(x) = \\frac{g_{x-1} + g_{x+1}}{2} + k\n$$\n\n當下其實沒有考慮太多數學上的事，就是很直覺的隨便寫了一些算法，\n然後丟試算表或是丟腳本（程式）跑跑看，接著驗收跑出來的圖。\n\n![](#chart-1.webp)\n\nx 軸是微元素的一維分佈，y 軸是演算法迭代時間，分別在 $x=0,12,99$ 的地方放置支點，會吸收重力能。把 $t=1,000$ 的重力能分佈圖繪製出來：\n\n![](#chart-2.webp)\n\n...恩？我怎麼對這分佈好像有印象？\n\n![https://www.aboutcivil.org/imajes/Sfd-bmd-simple-beam-udl.JPG](#shear-moment-1.jpg)\n\n是出現在剪力-彎矩圖的彎矩啊啊！\n\n### 模型的數學解析\n\n若考慮一維空間中，每個微元素含有「重力能」的函數為 $g(x)$，\n不考慮持續施加的重力能，僅考慮流動，離散描述：\n$$\ng'(x) = \\frac{g_{x-1} + g_{x+1}}{2}\n$$\n\n經過整理可以得到：\n$g'(x) = \n\\frac1{2} ((g_{x-1} - g_x)+( g_{n+1} - g_x)) + g_x$\n\n因此可以導出：\n$\\frac{\\Delta g }{\\Delta t}= \n\\frac1{2} ((g_{x-1} - g_x)+( g_{x+1} - g_x))$\n\n繼續整理：\n$\\frac{\\Delta g }{\\Delta t}= \n\\frac1{2} (( g_{x+1} - g_x) - (g_{x} - g_{x-1}))$\n\n這是什麼呢？\n$$\n\\begin{align}\n  \\frac{\\Delta g }{\\Delta t}\n    &= \\frac1{2} (\\frac{\\Delta g_{x+1}}{\\Delta x} - \\frac{\\Delta g_{x}}{\\Delta x}) \\\\\n    &=\\frac12 \\frac{\\Delta \\Delta g}{\\Delta x\\Delta x}\n\\end{align}\n$$\n\n寫成連續型態：\n$$\n\\frac{dg}{dt} = \\frac{d^2 g}{dx^2}\n$$\n\n這不是熱傳方程式嗎！？(╯°Д°)╯︵ ノ(｡ー｡)ヽ\n\n對吼，畢竟就是用流動的概念去寫的，難怪會跑出熱傳（擴散）方程式 (ヽ°Д°)ヽ ヽ( °_° )ノ\n\n### 解微分方程\n好噠，手上有一個微分方程，這讓我很好奇 $g$ 究竟長怎樣\n$$\n\\frac{d\\,g}{d\\,t} = \\frac{d^2\\,g}{d\\,x^2} +k\n$$\n\n首先，我想知道運算收斂時 $g$ 的狀態，因此：\n$$\n\\frac{d^2\\,g}{d\\,x^2}=-k \\Big|_{\\frac{d\\,g}{d\\,t}=0}\n$$\n\n積分兩次我會得到：\n$$\ng(x)=-\\frac12 k x^2 + c_1 x + c_2\n$$\n\n這是...開口朝下的拋物線呢！跟畫出來的曲線一樣呢！(´°ω°\\`)\n\n### 其他嘗試 - 有限重力能\n在幾個早期版本的腳本測試中，我並沒有注意到收斂的現象，\n應該是撰寫的腳本本身有 BUG，print 出來的數值會發散，\n於是我試著加入條件：\n> 整個系統的「重力能」是有限的\n\n也就是對整個系統而言，重力能的變化為零：\n$$\n\\int_{\\Bbb S} \\frac{d\\,g}{d\\,t} d\\,t =0\n$$\n\n這使得 $k$ 不再是常數，實驗結果如下：\n\n![](#chart-3.webp)\n\n在 $t=100$ 的狀態畫成 g-x 曲線圖：\n\n![](#chart-4.webp)\n\n重力能都被間距比較大的區域吃掉啦！！ ((( °Д°)))\n\n### 看起來它真的是彎矩\n![http://www.fao.org/3/s1250e/S1250E46.GIF](#shear-moment-2.gif)\n\n在均佈荷重的力學模型中，\n\n$$\nV(x)=-\\int w(x)\\,dx \\\\\nM(x)=\\int V(x)\\,dx\n$$\n\n$M$：彎矩，$V$：剪力，$w$單位梁受力。\n\n彎矩對距離微分兩次就會得到梁的單位受力 $(N/m)$。[^Direct_integration_of_a_beam]\n\n接著我分別把簡支梁（連續樑）和懸臂梁（外伸樑）的數值丟進試算表求微分值：\n\n![](#chart-5.webp)\n\n![](#chart-6.webp)\n\n重力能的分佈和彎矩圖其實很接近，但是就是垂直軸的位置不太對，翻了翻資料發現是因為我沒加入 $\\sum M= 0$ 的平衡條件。\n\n人工在試算表裡修正後就會得到圖中紅色的部份，看起來的確比較像材料力學裡的彎矩分佈圖了，\n透過微分也很明顯的看到剪力和荷重得出現了。\n\n不過運算出來的荷重和我一開始施加的 $k$ 有一點點落差，誤差百分比高達 30% 。\n\n不過只是要用來懲罰機器學習用的，不用太準應該也沒關係吧（？\n\n接下來的課題是：\n> 如何在元素的迭代過程自然的收斂成被修正的「彎矩值」？\n\n### 修飾重力能\n我們可以發現「重力能」是大於零的參數，其和必不等於零，\n可以透過該方式補正：\n$$\ng_m(x) = g(x) + m\n$$\n\n$g_m$：修飾重力能，修正後的重力能用來匹配相對真實的彎矩分佈。\n$g$：原始重力能。\n$m$：修正項，為了使彎矩值滿足平衡條件 $\\sum M =0$\n\n修正項應該為重力能加總的平均值：\n$$\nm = -\\frac1x \\int g d\\,x\n$$\n\n透過和重力能一樣的計算方式，使用流動的方式來收斂解：\n$$\n\\frac{d\\,m}{d\\,t} = \\frac{d\\,g}{d\\,t} + \\frac{d^2\\,m}{d\\,x^2}\n$$\n\n當重力能收斂時，即 $\\frac{d\\,g}{d\\,t}$ 趨近於零，修正項 $m$ 的變化便會受到擴散微分項主導，最終趨於平均分佈。\n\n重構之後加入修正項的程式結果（迭代次數：1000 ），原始值：\n![](#chart-7.webp)\n\n修正項：\n![](#chart-8.webp)\n\n修正值：\n![](#chart-9.webp)\n\n### 二維模型驗證\n完成一維模型驗證之後，接下來換二維了，\n不過為了方便下一個階段（三維）的驗證，程式碼是直接寫成三維的。\n一個 chunk 是由 $100 \\times 100 \\times 100$ 個元素構成，\n下圖是 $(x,0,z)$ 平面的剖面圖迭代 1000 次的收斂過程：\n\n[![](https://i.imgur.com/aTH8wTl.gif)](./video/test-1.mp4)\n\n### 加入破壞機制\n崩潰模型採用：當重力能或修正重力能大於臨界點便直接移除該方塊。\n\n[![](https://i.imgur.com/elrEx8Z.gif)](./video/test-2.mp4)\n\n### 程式碼\nhttps://github.com/FlySkyPie/the-architectural-construction-punishment-by-mechanical-failure-in-voxel-source\n\n---\n\n[![創用 CC 授權條款](https://i.creativecommons.org/l/by-sa/4.0/88x31.webp)](http://creativecommons.org/licenses/by-sa/4.0/)  \nWei Ji以[創用CC 姓名標示-相同方式分享 4.0 國際 授權條款](http://creativecommons.org/licenses/by-sa/4.0/)釋出。\n\n[^Powder_Toy]: The Powder Toy - Wikipedia. (n.d.).Retrieved 2020-01-09, from https://en.wikipedia.org/wiki/The_Powder_Toy\n\n[^BlockPhysics]:  BlockPhysics Mod 1.7.10 (Real Collision) - 9Minecraft.Net. (n.d.). Retrieved 2020-01-09, from http://www.9minecraft.net/blockphysics-mod/\n\n[^Direct_integration_of_a_beam]: Direct integration of a beam - Wikipedia. (n.d.). Retrieved 2020-01-09, from https://en.wikipedia.org/wiki/Direct_integration_of_a_beam\n","type":"text/markdown","created":"20231102113533593","modified":"20231102131526856","tags":"ASMCBNFH","revision":"0","bag":"default"}